<h1>Examples</h1>
<pre><code class="lang-js">// Simple config to run jshint any time a file is added, changed or deleted
grunt.initConfig({
  watch: {
    files: [&#39;**/*&#39;],
    tasks: [&#39;jshint&#39;],
  },
});</code></pre>
<pre><code class="lang-js">// Advanced config. Run specific tasks when specific files are added, changed or deleted.
grunt.initConfig({
  watch: {
    gruntfile: {
      files: &#39;Gruntfile.js&#39;,
      tasks: [&#39;jshint:gruntfile&#39;],
    },
    src: {
      files: [&#39;lib/*.js&#39;, &#39;css/**/*.scss&#39;, &#39;!lib/dontwatch.js&#39;],
      tasks: [&#39;default&#39;],
    },
    test: {
      files: &#39;&lt;%= jshint.test.src %&gt;&#39;,
      tasks: [&#39;jshint:test&#39;, &#39;qunit&#39;],
    },
  },
});</code></pre>
<h2>Using the <code>watch</code> event</h2>
<p>This task will emit a <code>watch</code> event when watched files are modified. This is useful if you would like a simple notification when files are edited or if you&#39;re using this task in tandem with another task. Here is a simple example using the <code>watch</code> event:</p>
<pre><code class="lang-js">grunt.initConfig({
  watch: {
    scripts: {
      files: [&#39;lib/*.js&#39;],
    },
  },
});
grunt.event.on(&#39;watch&#39;, function(action, filepath, target) {
  grunt.log.writeln(target + &#39;: &#39; + filepath + &#39; has &#39; + action);
});</code></pre>
<p><strong>The <code>watch</code> event is not intended for replacing the standard Grunt API for configuring and running tasks. If you&#39;re trying to run tasks from within the <code>watch</code> event you&#39;re more than likely doing it wrong. Please read <a href="http://gruntjs.com/configuring-tasks">configuring tasks</a>.</strong></p>
<h3>Compiling Files As Needed</h3>
<p>A very common request is to only compile files as needed. Here is an example that will only lint changed files with the <code>jshint</code> task:</p>
<pre><code class="lang-js">grunt.initConfig({
  watch: {
    scripts: {
      files: [&#39;lib/*.js&#39;],
      tasks: [&#39;jshint&#39;],
      options: {
        spawn: false,
      },
    },
  },
  jshint: {
    all: [&#39;lib/*.js&#39;],
  },
});

// on watch events configure jshint:all to only run on changed file
grunt.event.on(&#39;watch&#39;, function(action, filepath) {
  grunt.config([&#39;jshint&#39;, &#39;all&#39;], filepath);
});</code></pre>
<p>If you need to dynamically modify your config, the <code>spawn</code> option must be disabled to keep the watch running under the same context.</p>
<p>If you save multiple files simultaneously you may opt for a more robust method:</p>
<pre><code class="lang-js">var changedFiles = Object.create(null);
var onChange = grunt.util._.debounce(function() {
  grunt.config([&#39;jshint&#39;, &#39;all&#39;], Object.keys(changedFiles));
  changedFiles = Object.create(null);
}, 200);
grunt.event.on(&#39;watch&#39;, function(action, filepath) {
  changedFiles[filepath] = action;
  onChange();
});</code></pre>
<h2>Live Reloading</h2>
<p>Live reloading is built into the watch task. Set the option <code>livereload</code> to <code>true</code> to enable on the default port <code>35729</code> or set to a custom port: <code>livereload: 1337</code>.</p>
<p>The simplest way to add live reloading to all your watch targets is by setting <code>livereload</code> to <code>true</code> at the task level. This will run a single live reload server and trigger the live reload for all your watch targets:</p>
<pre><code class="lang-js">grunt.initConfig({
  watch: {
    options: {
      livereload: true,
    },
    css: {
      files: [&#39;public/scss/*.scss&#39;],
      tasks: [&#39;compass&#39;],
    },
  },
});</code></pre>
<p>You can also configure live reload for individual watch targets or run multiple live reload servers. Just be sure if you&#39;re starting multiple servers they operate on different ports:</p>
<pre><code class="lang-js">grunt.initConfig({
  watch: {
    css: {
      files: [&#39;public/scss/*.scss&#39;],
      tasks: [&#39;compass&#39;],
      options: {
        // Start a live reload server on the default port 35729
        livereload: true,
      },
    },
    another: {
      files: [&#39;lib/*.js&#39;],
      tasks: [&#39;anothertask&#39;],
      options: {
        // Start another live reload server on port 1337
        livereload: 1337,
      },
    },
    dont: {
      files: [&#39;other/stuff/*&#39;],
      tasks: [&#39;dostuff&#39;],
    },
  },
});</code></pre>
<h3>Enabling Live Reload in Your HTML</h3>
<p>Once you&#39;ve started a live reload server you&#39;ll be able to access the live reload script. To enable live reload on your page, add a script tag before your closing <code>&lt;/body&gt;</code> tag pointing to the <code>livereload.js</code> script:</p>
<pre><code class="lang-html">&lt;script src=&quot;http://localhost:35729/livereload.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>Feel free to add this script to your template situation and toggle with some sort of <code>dev</code> flag.</p>
<h3>Using Live Reload with the Browser Extension</h3>
<p>Instead of adding a script tag to your page, you can live reload your page by installing a browser extension. Please visit <a href="http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-">how do I install and use the browser extensions</a> for help installing an extension for your browser.</p>
<p>Once installed please use the default live reload port <code>35729</code> and the browser extension will automatically reload your page without needing the <code>&lt;script&gt;</code> tag.</p>
<h3>Using Connect Middleware</h3>
<p>Since live reloading is used when developing, you may want to disable building for production (and are not using the browser extension). One method is to use Connect middleware to inject the script tag into your page. Try the <a href="https://github.com/intesso/connect-livereload">connect-livereload</a> middleware for injecting the live reload script into your page.</p>
<h3>Rolling Your Own Live Reload</h3>
<p>Live reloading is made easy by the library <a href="https://github.com/mklabs/tiny-lr">tiny-lr</a>. It is encouraged to read the documentation for <code>tiny-lr</code>. If you would like to trigger the live reload server yourself, simply POST files to the URL: <code>http://localhost:35729/changed</code>. Or if you rather roll your own live reload implementation use the following example:</p>
<pre><code class="lang-js">// Create a live reload server instance
var lrserver = require(&#39;tiny-lr&#39;)();

// Listen on port 35729
lrserver.listen(35729, function(err) { console.log(&#39;LR Server Started&#39;); });

// Then later trigger files or POST to localhost:35729/changed
lrserver.changed({body:{files:[&#39;public/css/changed.css&#39;]}});</code></pre>
<h3>Live Reload with Preprocessors</h3>
<p>Any time a watched file is edited with the <code>livereload</code> option enabled, the file will be sent to the live reload server. Some edited files you may desire to have sent to the live reload server, such as when preprocessing (<code>sass</code>, <code>less</code>, <code>coffeescript</code>, etc). As any file not recognized will reload the entire page as opposed to just the <code>css</code> or <code>javascript</code>.</p>
<p>The solution is to point a <code>livereload</code> watch target to your destination files:</p>
<pre><code class="lang-js">grunt.initConfig({
  sass: {
    dev: {
      src: [&#39;src/sass/*.sass&#39;],
      dest: &#39;dest/css/index.css&#39;,
    },
  },
  watch: {
    sass: {
      // We watch and compile sass files as normal but don&#39;t live reload here
      files: [&#39;src/sass/*.sass&#39;],
      tasks: [&#39;sass&#39;],
    },
    livereload: {
      // Here we watch the files the sass task will compile to
      // These files are sent to the live reload server after sass compiles to them
      options: { livereload: true },
      files: [&#39;dest/**/*&#39;],
    },
  },
});</code></pre>
<h1>FAQs</h1>
<h2>How do I fix the error <code>EMFILE: Too many opened files.</code>?</h2>
<p>This is because of your system&#39;s max opened file limit. For OSX the default is very low (256). Temporarily increase your limit with <code>ulimit -n 10480</code>, the number being the new max limit.</p>
<p>In some versions of OSX the above solution doesn&#39;t work. In that case try <code>launchctl limit maxfiles 10480 10480</code> and restart your terminal. See <a href="http://superuser.com/questions/261023/how-to-change-default-ulimit-values-in-mac-os-x-10-6">here</a>.</p>
<h2>Can I use this with Grunt v0.3?</h2>
<p>Yes. Although <code>grunt-contrib-watch</code> is a replacement watch task for Grunt v0.4, version <code>grunt-contrib-watch@0.1.x</code> is compatible with Grunt v0.3. <code>grunt-contrib-watch &gt;= 0.2.x</code> is <em>*only</em> compatible and recommended to use with Grunt v0.4.</p>
<h2>Why is the watch devouring all my memory/cpu?</h2>
<p>Likely because of an enthusiastic pattern trying to watch thousands of files. Such as <code>&#39;**/*.js&#39;</code> but forgetting to exclude the <code>node_modules</code> folder with <code>&#39;!**/node_modules/**&#39;</code>. Try grouping your files within a subfolder or be more explicit with your file matching pattern.</p>
<p>Another reason if you&#39;re watching a large number of files could be the low default <code>interval</code>. Try increasing with <code>options: { interval: 5007 }</code>. Please see issues <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/145">#35</a> and <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/145">#145</a> for more information.</p>
<h2>Why spawn as child processes as a default?</h2>
<p>The goal of this watch task is as files are changed, run tasks as if they were triggered by the user themself. Each time a user runs <code>grunt</code> a process is spawned and tasks are ran in succession. In an effort to keep the experience consistent and continually produce expected results, this watch task spawns tasks as child processes by default.</p>
<p>Sandboxing task runs also allows this watch task to run more stable over long periods of time. As well as more efficiently with more complex tasks and file structures.</p>
<p>Spawning does cause a performance hit (usually 500ms for most environments). It also cripples tasks that rely on the watch task to share the context with each subsequent run (i.e., reload tasks). If you would like a faster watch task or need to share the context please set the <code>spawn</code> option to <code>false</code>. Just be aware that with this option enabled, the watch task is more prone to failure.</p>
